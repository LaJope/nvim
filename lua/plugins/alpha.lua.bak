function parse_ansi_to_hl(ansi_text)
  local lines = vim.split(ansi_text, "\n")
  local parsed_lines = {}
  local hl_groups = {}

  for _, line in ipairs(lines) do
    local parsed_line = {}
    local current_fg = nil
    local current_bg = nil

    -- Extract ANSI codes and text segments
    for code, text in line:gmatch("(\x1b%[[^m]+m)([^\x1b]*)") do
      -- Parse foreground color (38;2;R;G;B)
      local fg_r, fg_g, fg_b = code:match("38;2;(%d+);(%d+);(%d+)")
      if fg_r then
        current_fg = {
          R = tonumber(fg_r),
          G = tonumber(fg_g),
          B = tonumber(fg_b),
        }
      end

      -- Parse background color (48;2;R;G;B)
      local bg_r, bg_g, bg_b = code:match("48;2;(%d+);(%d+);(%d+)")
      if bg_r then
        current_bg = {
          R = tonumber(bg_r),
          G = tonumber(bg_g),
          B = tonumber(bg_b),
        }
      end

      -- Reset colors
      if code:match("0m") then
        current_fg = nil
        current_bg = nil
      end

      -- Store the segment with its colors
      if text ~= "" then
        table.insert(parsed_line, {
          text = text,
          fg = current_fg,
          bg = current_bg,
        })
      end
    end

    table.insert(parsed_lines, parsed_line)
  end

  -- Generate highlight groups for each unique color
  for _, line in ipairs(parsed_lines) do
    for _, segment in ipairs(line) do
      if segment.fg then
        local hl_name = string.format("AnsiFg_%d_%d_%d", segment.fg.R, segment.fg.G, segment.fg.B)
        if not hl_groups[hl_name] then
          vim.api.nvim_set_hl(
            0,
            hl_name,
            { fg = string.format("#%02x%02x%02x", segment.fg.R, segment.fg.G, segment.fg.B) }
          )
          hl_groups[hl_name] = true
        end
      end
      if segment.bg then
        local hl_name = string.format("AnsiBg_%d_%d_%d", segment.fg.R, segment.fg.G, segment.fg.B)
        if not hl_groups[hl_name] then
          vim.api.nvim_set_hl(
            0,
            hl_name,
            { bg = string.format("#%02x%02x%02x", segment.fg.R, segment.fg.G, segment.fg.B) }
          )
          hl_groups[hl_name] = true
        end
      end
    end
  end

  return parsed_lines
end

local file = io.popen("chafa -f symbols ~/HDD/Backgrounds/.private/EtEKwDMW4AMEOSq.jpg -c full --scale 0.2")

local image = file:read("*a")
local parsed_art = parse_ansi_to_hl(image)
file:close()
local formatted_lines = {}
local hl_segments = {}
for _, line in ipairs(parsed_art) do
  local formatted_line = ""
  local col_start = 0

  for _, segment in ipairs(line) do
    formatted_line = formatted_line .. segment.text
    if segment.bg then
      local hl_name = string.format("AnsiBg_%d_%d_%d", segment.bg.R, segment.bg.G, segment.bg.B)
      table.insert(hl_segments, { hl_name, #formatted_lines + 1, col_start, col_start + #segment.text })
    end
    col_start = col_start + #segment.text
  end

  table.insert(formatted_lines, formatted_line)
end

--print(formatted_lines[1])
--print(hl_segments[1][1])

------------------- ---------------- ---------------- ----------------
local function newFile()
  local filename = vim.fn.input("Filename: ")
  if filename == "" then
    return
  end
  vim.cmd("e " .. filename)
end

local cd_command = "<cmd>cd " .. CONFIG_PATH .. "<CR>"

local display = {}
--dashboard.section.header.val = formatted_lines
--dashboard.section.header.opts.hl = hl_segments -- Apply highlights

local header = {
  opts = {
    position = "center",
    hl = hl_segments,
  },
  type = "text",
  val = formatted_lines,
}
--local header = {
--	opts = { position = "center" },
--	type = "text",
--	val = display,
--}

local function config()
  local theme = require("alpha.themes.theta")

  local dashboard = require("alpha.themes.dashboard")
  theme.buttons.val = {
    {
      type = "text",
      val = "Quick links",
      opts = { hl = "SpecialComment", position = "center" },
    },
    { type = "padding", val = 1 },
    ---@diagnostic disable-next-line: param-type-mismatch
    dashboard.button("e", "  New file", newFile),
    dashboard.button("<spc>pf", "󰈞  Find file", "<cmd>Telescope find_files<CR>"),
    dashboard.button("<spc>pe", "󰈞  Find file (frecency)", "<cmd>Telescope frecency workspace=CWD<CR>"),
    dashboard.button("<spc>pg", "󰊄  Live grep", "<cmd>Telescope live_grep"),
    dashboard.button("c", "  Configuration", cd_command),
    dashboard.button("l", "  Open lazy", "<cmd>Lazy<CR>"),
    dashboard.button("m", "  Open mason", "<cmd>Mason<CR>"),
    dashboard.button("q", "󰅚  Quit", "<cmd>qa<CR>"),
  }

  theme.file_icons.provider = "devicons"

  local mru = theme.mru
  local section_mru = {
    type = "group",
    val = {
      {
        type = "text",
        val = "Recent files",
        opts = {
          hl = "SpecialComment",
          shrink_margin = false,
          position = "center",
        },
      },
      { type = "padding", val = 1 },
      {
        type = "group",
        val = function()
          return { mru(1, vim.fn.getcwd()) }
        end,
        opts = { shrink_margin = false },
      },
    },
  }

  if #header.val == 0 then
    header = theme.header
  end

  theme.config.layout = {
    { type = "padding", val = 2 },
    header,
    { type = "padding", val = 2 },
    section_mru,
    { type = "padding", val = 2 },
    theme.buttons,
  }

  require("alpha").setup(theme.config)
end

return {
  "goolord/alpha-nvim",
  dependencies = { "nvim-tree/nvim-web-devicons" },
  config = config,
}
